
---
layout:     post
title:      "stl"
subtitle:   "stl"
date:       2019-06-10 20:30:33
author:     "none"
header-img: "img/posts/default_post.jpg"
catalog: true
tags:
    - tag
---
# stl

STL六大组件
- 容器(container)
- 迭代器(iterator)
- 算法(algorithm)
- 配置器(allocator)
- 仿函数(functor)
- 适配器(adapter)

# vector

## push_back 和 emplace_back
emplace_back会原地对参数进行构造，
push_back要么会拷贝参数，要么会构造后需要移动操作

## clear 
clear 后vector的size=0, 但capacity不变

如何改变vector的capacity
```
vector<T>().swap(var)
var.shrink_to_fit()
```

# deque
- 分段连续空间
- 没有capacity的概念

# queue 和 stack
一般底层使用的是deque， 没有迭代器
一般称为adapter而不是container


# 文件读写
不要使用eof进行判断，会导致循环多一次
```
#include <string>
#include <fstream>

int main() {
    std::ifstream in_file("doc_id.txt");
    if(!in_file.is_open()) return -1;

    std::string line;
    //while(!in_file.eof()) {
    //while (std::getline(ifs, line)) {
    while(in_file >> line) {
        std::getline(in_file, line);
    }
}
```


# 迭代器 iterator


## 迭代器失效

引起容器内存发生变化的操作，都有可能造成迭代器失效

插入和删除操作后，获取有效的迭代器
```
iter=vec.insert(iter);
iter=vec.erase(iter);
```

vector
- 插入操作(push_back, insert), vector中元素总数仍不大于capacity，这时插入位置后的元素都被依次移动到下一个位置，所以插入位置之后的迭代器都会失效; vector中元素总数大于capacity，这个时候会重新开辟更大的内存空间，将原来的vector中的内容复制到新的vector中，回收原先vector的内存空间。由于新的vector的地址已完全改变，所以原先的所有迭代器都会失效。
- 删除操作(pop_back, erase), 删除位置后的元素都被依次复制到前一个位置，所以删除位置之后的迭代器都会失效。


# unordered_map

- hash 函数
- 相等函数，解决hash碰撞


# typename
默认情况下，C++ 语言假定通过作用域运算符访问的名字不是类型， 可以通过typename标识其为类型
```c++
template<typename T>
typename T::value_type top(const T &c)
{
    return typename T::value_type();
}
```
期望T为容器类型， top函数的返回类型为T::value_type， 使用了域运算符时需要使用typename标识为类型

# traits
traits是一种类型推断技术，利用模板特化在编译期间获取类型信息

算法是如何从迭代器类中萃取出容器元素的类型

traits 实现方式
- value_type 和 typename
- 模板偏特化 template partial specialization （原生指针无法定义value_type, pointer-to-const)


# typeid
RTTI（Run-Time Type Identification)

运行时获知变量类型名称, typeid(变量).name()

```

std::string st = "hello world";
if(typeid(st) == typeid(std::string)) {

}
```

# lock_guard 和 unique_lock
unique_lock允许调用lock()和unlock()来切换锁的状态

condition_variable的wait需要配合unique_lock来使用，因为wait函数伪代码如下：
```c++
condition_variable::wait(std::unique_lock<std::mutex>& lk){
      lk.unlock();

      waiting_signal();

      lk.lock();
}
```
先将锁处于解锁状态，
